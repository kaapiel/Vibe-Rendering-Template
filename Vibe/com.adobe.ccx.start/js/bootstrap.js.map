{"version":3,"sources":["loadjs.js","bootstrap.js"],"names":["loadjs","subscribe","bundleIds","callbackFn","push","fn","bundleId","r","q","depsNotFound","i","length","numWaiting","pathsNotFound","bundleResultCache","bundleCallbackQueue","publish","splice","loadFile","path","args","numTries","isCss","e","doc","document","async","maxTries","numRetries","beforeCallbackFn","before","devnull","test","createElement","rel","href","replace","src","undefined","onload","onerror","onbeforeload","ev","result","type","sheet","cssText","x","defaultPrevented","head","appendChild","loadFiles","paths","arg1","arg2","trim","bundleIdCache","error","success","ready","deps","done","reset","isDefined"],"mappings":"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","file":"bootstrap.js","sourcesContent":["loadjs = (function () {\n/**\n * Global dependencies.\n * @global {Object} document - DOM\n */\n\nvar devnull = function() {},\n    bundleIdCache = {},\n    bundleResultCache = {},\n    bundleCallbackQueue = {};\n\n\n/**\n * Subscribe to bundle load event.\n * @param {string[]} bundleIds - Bundle ids\n * @param {Function} callbackFn - The callback function\n */\nfunction subscribe(bundleIds, callbackFn) {\n  // listify\n  bundleIds = bundleIds.push ? bundleIds : [bundleIds];\n\n  var depsNotFound = [],\n      i = bundleIds.length,\n      numWaiting = i,\n      fn,\n      bundleId,\n      r,\n      q;\n\n  // define callback function\n  fn = function (bundleId, pathsNotFound) {\n    if (pathsNotFound.length) depsNotFound.push(bundleId);\n\n    numWaiting--;\n    if (!numWaiting) callbackFn(depsNotFound);\n  };\n\n  // register callback\n  while (i--) {\n    bundleId = bundleIds[i];\n\n    // execute callback if in result cache\n    r = bundleResultCache[bundleId];\n    if (r) {\n      fn(bundleId, r);\n      continue;\n    }\n\n    // add to callback queue\n    q = bundleCallbackQueue[bundleId] = bundleCallbackQueue[bundleId] || [];\n    q.push(fn);\n  }\n}\n\n\n/**\n * Publish bundle load event.\n * @param {string} bundleId - Bundle id\n * @param {string[]} pathsNotFound - List of files not found\n */\nfunction publish(bundleId, pathsNotFound) {\n  // exit if id isn't defined\n  if (!bundleId) return;\n\n  var q = bundleCallbackQueue[bundleId];\n\n  // cache result\n  bundleResultCache[bundleId] = pathsNotFound;\n\n  // exit if queue is empty\n  if (!q) return;\n\n  // empty callback queue\n  while (q.length) {\n    q[0](bundleId, pathsNotFound);\n    q.splice(0, 1);\n  }\n}\n\n\n/**\n * Load individual file.\n * @param {string} path - The file path\n * @param {Function} callbackFn - The callback function\n */\nfunction loadFile(path, callbackFn, args, numTries) {\n  var doc = document,\n      async = args.async,\n      maxTries = (args.numRetries || 0) + 1,\n      beforeCallbackFn = args.before || devnull,\n      isCss,\n      e;\n\n  numTries = numTries || 0;\n\n  if (/(^css!|\\.css$)/.test(path)) {\n    isCss = true;\n\n    // css\n    e = doc.createElement('link');\n    e.rel = 'stylesheet';\n    e.href = path.replace(/^css!/, '');  // remove \"css!\" prefix\n  } else {\n    // javascript\n    e = doc.createElement('script');\n    e.src = path;\n    e.async = async === undefined ? true : async;\n  }\n\n  e.onload = e.onerror = e.onbeforeload = function (ev) {\n    var result = ev.type[0];\n\n    // Note: The following code isolates IE using `hideFocus` and treats empty\n    // stylesheets as failures to get around lack of onerror support\n    if (isCss && 'hideFocus' in e) {\n      try {\n        if (!e.sheet.cssText.length) result = 'e';\n      } catch (x) {\n        // sheets objects created from load errors don't allow access to\n        // `cssText`\n        result = 'e';\n      }\n    }\n\n    // handle retries in case of load failure\n    if (result == 'e') {\n      // increment counter\n      numTries += 1;\n\n      // exit function and try again\n      if (numTries < maxTries) {\n        return loadFile(path, callbackFn, args, numTries);\n      }\n    }\n\n    // execute callback\n    callbackFn(path, result, ev.defaultPrevented);\n  };\n\n  // add to document (unless callback returns `false`)\n  if (beforeCallbackFn(path, e) !== false) doc.head.appendChild(e);\n}\n\n\n/**\n * Load multiple files.\n * @param {string[]} paths - The file paths\n * @param {Function} callbackFn - The callback function\n */\nfunction loadFiles(paths, callbackFn, args) {\n  // listify paths\n  paths = paths.push ? paths : [paths];\n\n  var numWaiting = paths.length,\n      x = numWaiting,\n      pathsNotFound = [],\n      fn,\n      i;\n\n  // define callback function\n  fn = function(path, result, defaultPrevented) {\n    // handle error\n    if (result == 'e') pathsNotFound.push(path);\n\n    // handle beforeload event. If defaultPrevented then that means the load\n    // will be blocked (ex. Ghostery/ABP on Safari)\n    if (result == 'b') {\n      if (defaultPrevented) pathsNotFound.push(path);\n      else return;\n    }\n\n    numWaiting--;\n    if (!numWaiting) callbackFn(pathsNotFound);\n  };\n\n  // load scripts\n  for (i=0; i < x; i++) loadFile(paths[i], fn, args);\n}\n\n\n/**\n * Initiate script load and register bundle.\n * @param {(string|string[])} paths - The file paths\n * @param {(string|Function)} [arg1] - The bundleId or success callback\n * @param {Function} [arg2] - The success or error callback\n * @param {Function} [arg3] - The error callback\n */\nfunction loadjs(paths, arg1, arg2) {\n  var bundleId,\n      args;\n\n  // bundleId (if string)\n  if (arg1 && arg1.trim) bundleId = arg1;\n\n  // args (default is {})\n  args = (bundleId ? arg2 : arg1) || {};\n\n  // throw error if bundle is already defined\n  if (bundleId) {\n    if (bundleId in bundleIdCache) {\n      throw \"LoadJS\";\n    } else {\n      bundleIdCache[bundleId] = true;\n    }\n  }\n\n  // load scripts\n  loadFiles(paths, function (pathsNotFound) {\n    // success and error callbacks\n    if (pathsNotFound.length) (args.error || devnull)(pathsNotFound);\n    else (args.success || devnull)();\n\n    // publish bundle load event\n    publish(bundleId, pathsNotFound);\n  }, args);\n}\n\n\n/**\n * Execute callbacks when dependencies have been satisfied.\n * @param {(string|string[])} deps - List of bundle ids\n * @param {Object} args - success/error arguments\n */\nloadjs.ready = function ready(deps, args) {\n  // subscribe to bundle load event\n  subscribe(deps, function (depsNotFound) {\n    // execute callbacks\n    if (depsNotFound.length) (args.error || devnull)(depsNotFound);\n    else (args.success || devnull)();\n  });\n\n  return loadjs;\n};\n\n\n/**\n * Manually satisfy bundle dependencies.\n * @param {string} bundleId - The bundle id\n */\nloadjs.done = function done(bundleId) {\n  publish(bundleId, []);\n};\n\n\n/**\n * Reset loadjs dependencies statuses\n */\nloadjs.reset = function reset() {\n  bundleIdCache = {};\n  bundleResultCache = {};\n  bundleCallbackQueue = {};\n};\n\n\n/**\n * Determine if bundle has already been defined\n * @param String} bundleId - The bundle id\n */\nloadjs.isDefined = function isDefined(bundleId) {\n  return bundleId in bundleIdCache;\n};\n\n\n// export\nreturn loadjs;\n\n})();\n","// load head and iaw to start things off\nloadjs(['js/moment.min.js', 'js/ingest-api.min.js', 'js/md5.min.js', 'js/spectre-ui.min.js'], {\n\tsuccess: function() {\n\t\t// now that the deps are loaded, load the app\n\t\tloadjs(['js/app.js']);\n\t}\n});\n"]}